package android.example.djlee.bubbleshooting;

import java.util.ArrayList;
import java.util.Random;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.view.Display;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceHolder.Callback;
import android.view.SurfaceView;
import android.view.WindowManager;

public class MyGameView extends SurfaceView implements Callback {
	GameThread mThread;		SurfaceHolder mHolder;
	Context mContext;
	public void stopGame(){
		mThread.stopThread();
	}
	public void pauseGame(){
		mThread.pauseNResume(true);
	}
	public void resumeGame(){
		mThread.pauseNResume(false);
	}
	public void restartGame(){
		mThread.stopThread();
		mThread = null;
		mThread = new GameThread(mHolder, mContext);
		mThread.start();
	}
	public MyGameView(Context context) {
		super(context);
		mHolder = getHolder();		mHolder.addCallback(this);
		mContext = context;
		mThread = new GameThread(mHolder, context);
	}
	class GameThread extends Thread{
		SurfaceHolder sHolder; Context mContext;
		int width, height; Bitmap imgBack;
		/////////총알 처리/////////////
		Bitmap imgSpider;//거미
		int sw,sh;//거미의 크기
		int mx,my;//거미의 좌표
		long lastTime;//시간 계산 용
		ArrayList<WaterBall> wBall = new ArrayList<WaterBall>();
		int tot = 0;//점수 합계
		Paint paint = new Paint();
		ArrayList<Score> mScore = new ArrayList<Score>();
		/////////총알 처리/////////////
		ArrayList<Bubble> mBall = new ArrayList<Bubble>();
		ArrayList<SmallBall> sBall=new ArrayList<SmallBall>();
		boolean canRun = true;//스레드 종료를 위한 변수
		boolean isWait = false;//스레드 대기를 위한 변수
		GameThread(SurfaceHolder holder, Context context){
			sHolder = holder; mContext = context;
			Display display = ((WindowManager)context.getSystemService(
				Context.WINDOW_SERVICE)).getDefaultDisplay();
			width = display.getWidth(); height = display.getHeight();
			imgBack=BitmapFactory.decodeResource(getResources(), 
					R.drawable.sky);//배경이미지 비트맵 생성
			imgBack=Bitmap.createScaledBitmap(imgBack, 
					width, height, false);//배경이미지를 화면에 맞게 보정
			imgSpider=BitmapFactory.decodeResource(getResources(), 
					R.drawable.spider1);
			sw = imgSpider.getWidth()/2; sh=imgSpider.getHeight()/2;
			mx = width/2; my = height -200;
			//거미의 위치는 가운데 화면 아래에서 위로 200올라간 위치
			paint.setAntiAlias(true);
			paint.setTextSize(50);
			paint.setColor(Color.WHITE);
			setFocusable(true);//포커스를 설정
		}
		public void drawCharacter(Canvas canvas){//풍선,작은풍선,총알을 그리는 메서드
			canvas.drawBitmap(imgBack, 0, 0, null);//배경
			for(Bubble tmp: mBall){
				canvas.drawBitmap(tmp.imgBall, tmp.x-tmp.rad,
						tmp.y-tmp.rad, null);
			}
			for(SmallBall tmp : sBall){
				canvas.drawBitmap(tmp.imgBall, tmp.x-tmp.rad,
						tmp.y-tmp.rad, null);
			}
			for(WaterBall tmp : wBall){
				canvas.drawBitmap(tmp.imgBall, tmp.x-tmp.rad,
						tmp.y-tmp.rad, null);
			}
			for(Score tmp : mScore){
				canvas.drawText("+100",tmp.x-20,tmp.y-10,tmp.paint);
			}
			canvas.drawText("총점:"+tot, 10, 30, paint);
			canvas.drawBitmap(imgSpider, mx-sw, my-sh,null);//거미
		}
		//풍선을 임의의 위치에 생성하는 메서드
		public void makeBubble(){
			Random rnd = new Random();
			if(mBall.size() > 100 || rnd.nextInt(40) < 38) 
				return;//물방울의 갯수가 최대 37 
			int x = -50;//왼쪽 방향에서 물방울이 생성되서 이동
			int y = rnd.nextInt(201) + 50;//50 ~ 250
			mBall.add(new Bubble(mContext,x,y,width,height));
		}
		
		//총알에 풍선이 맞았는지 판단 메서드
		public void checkCollision(){
			int x1,y1,x2,y2;
			for(WaterBall water : wBall){//모든 총알을 대상으로 한다.
				x1 = water.x; y1 = water.y;//각 총알의 좌표를 구한다.
				for(Bubble tmp : mBall){//모든 풍선을 대상으로 한다.
					x2 = tmp.x; y2 = tmp.y;//각 풍선의 좌표를 구한다.
					if(Math.abs(x1-x2)<tmp.rad && 
							Math.abs(y1-y2)<tmp.rad){
					//총알과 풍선의 좌표의 차이가 풍선의 반지름 안에 있으면 충돌을 의미한다.
						makeSmallBubble(tmp.x, tmp.y);//충돌했으므로 작은물방울만듬
						mScore.add(new Score(tmp.x, tmp.y));
						tot = tot + 100;
						tmp.dead = true;//풍선의 상태를 바꾼다.
						water.dead = true;//총알의 상태를 바꾼다.
						break;//풍선에 대한 반복 종료
					}
				}//풍선 반복 끝
			}//총알 반복 끝
		}//메서드의 끝
		
		//총알 발사(총알 생성) 메서드
		public void makeWaterBall(){
			long thisTime = System.currentTimeMillis();
			if(thisTime - lastTime >= 300){// 1/3초에 1개씩 발사
				wBall.add(new WaterBall(mContext,mx,my-20,width,height));
			}
			lastTime = thisTime;
			//즉,이전에 발사된 시간과 현재의 시간 차이가 300(0.3초)이상일 때만 총알이 발사
			//너무 총알을 빨리 발사하면 게임의 의미가 없으므로 적절하게 조절한다.
		}
		
		//모든 캐릭터(풍선,작은 풍선,총알)을 움직이는 메서드
		public void moveCharacters(){
			for(int i=mBall.size()-1; i >= 0; i--){//풍선
				mBall.get(i).moveBubble();
				if(mBall.get(i).dead == true) mBall.remove(i);
			}
			for(int i = sBall.size()-1; i>=0; i--){//작은 풍선
				sBall.get(i).moveBall();
				if(sBall.get(i).dead==true) sBall.remove(i);
			}
			for(int i = wBall.size()-1; i>=0; i--){//총알
				wBall.get(i).moveBall();
				if(wBall.get(i).dead==true) wBall.remove(i);
			}
			for(int i = mScore.size()-1; i>=0; i--){//점수
				if(mScore.get(i).move() == false){
					mScore.remove(i);
				}
			}
		}
		public void pauseNResume(boolean wait){//스레드 일시정지/재기동
			isWait = wait;
			synchronized(this){
				this.notify();
			}
		}
		public void stopThread(){//스레드 완전 종료
			canRun = false;
			synchronized(this){
				this.notify();//변수의 값을 바꾸고, 스레드의 run()을 호출
			}
		}
		
		//풍선을 이동하는 메서드. 스레드에서 사용
		public void moveBubble(){
			for(int i = mBall.size()-1; i >=0; i--){
				mBall.get(i).moveBubble();//풍선을 이동
				if(mBall.get(i).dead == true){
					makeSmallBubble(mBall.get(i).x,mBall.get(i).y);
					mBall.remove(i);//풍선의 상태가 true이면 ArrayList에서 삭제
				}
			}
			for(int i=sBall.size()-1; i>=0; i--){
				sBall.get(i).moveBall();//작은 풍선 이동
				if(sBall.get(i).dead == true){
					sBall.remove(i);//풍선의 상태가 true이면 ArrayList에서 삭제
				}
			}
		}
		//작은 풍선을 만드는 메서드
		public void makeSmallBubble(int x, int y){
			Random rnd = new Random();
			int count = rnd.nextInt(9) + 7;//7 ~ 15
			for(int i=1; i <=count; i++){
				int ang = rnd.nextInt(360);
				sBall.add(new SmallBall(mContext,x,y,ang,width,height));
			}
		}
		
		//풍선을 만드는 메서드. 화면을 터치했을 때
		public void makeBubble(int x, int y){
			boolean flag = false;
			for(Bubble bubble : mBall){
				if(Math.pow(bubble.x-x,2)+Math.pow(bubble.y-y,2)
						<= Math.pow(bubble.rad, 2)){//비누방울을 터치한 경우
					bubble.dead = true;//해당 비누방울의 상태를 변경
					flag = true;//비누방울을 터치했음을 설정
				}
			}//반복의 끝
			if(flag == false){//비누방울을 터치하지 않은 경우
				mBall.add(new Bubble(mContext,x,y,width,height));
				//비누방울을 생성해서 ArrayList에 저장
			}
		}
		public void run() {
			Canvas canvas = null;
			while(canRun){
				canvas = sHolder.lockCanvas();
				try{
					synchronized(sHolder){
						makeBubble();//풍선 자동 생성
						moveCharacters();//풍선,작은풍선,총알 이동
						checkCollision();//풍선과 총알 충돌 판단.
						drawCharacter(canvas);//풍선,작은풍선,총알 그림
//						moveBubble();
//						canvas.drawBitmap(imgBack, 0, 0,null);
//						for(Bubble bubble : mBall){
//							canvas.drawBitmap(bubble.imgBall, 
//							bubble.x - bubble.rad,
//							bubble.y - bubble.rad, null);
//						}//ArrayList에 있는 모든 풍선을 그린다.
//						for(SmallBall bubble : sBall){
//							canvas.drawBitmap(bubble.imgBall, 
//							bubble.x - bubble.rad, 
//							bubble.y - bubble.rad, null);
//						}
					}
				}finally{
					if(canvas != null)
						sHolder.unlockCanvasAndPost(canvas);
				}//try의 끝
				
				synchronized(this){
					if(isWait){
						try{
							wait();
						}catch(Exception e){}
					}
				}
			}//반복의 끝
		}//run()의 끝
	}//Thread의 끝
	
	@Override
	public boolean onTouchEvent(MotionEvent event) {
		if(event.getAction() == MotionEvent.ACTION_DOWN){
			synchronized(mHolder){
			//SurfaceHolder을 다른 스레드가 사용하지 못하게 동기화 한다.
				int x = (int)event.getX();
				int y = (int)event.getY();
//				mThread.makeBubble(x, y);
				mThread.makeWaterBall();//총알 생성
			}//풍선을 만드는 작업까지 한 후 동기화를 해제 한다.
		}//화면을 누른경우
		return super.onTouchEvent(event);
	}
	public void surfaceCreated(SurfaceHolder holder) {
		mThread.start();//스레드 시작
	}
	public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
	}
	public void surfaceDestroyed(SurfaceHolder holder) {
		boolean done = true;
		while(done){
			try{
				mThread.join();//mThread가 종료될 때까지 대기
				done = false;//mThread가 종료되면 반복이 종료
			}catch(Exception e){}
		}//스레드가 종료되기를 기다렸다가 서피스 뷰를 삭제한다.
	}
}










